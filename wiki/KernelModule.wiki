#summary How to use the kernel module
#labels Featured,Phase-Design

== Introduction ==

The module has an interface in /proc/overclock/ that allows enabling and disabling of overclock in runtime without rebooting. It works by changing several parameters directly in kernel memory to fool both CPUfreq and its lowlevel OMAP driver.

The MPU (Microprocessor Unit) clock has 5 discrete pairs of possible rate frequencies and respective voltages, of which only 4 are passed down to CPUfreq as you can see with a tool such as SetCPU.  The default frequencies are 125, 250, 500 and 550 MHz (and a hidden 600).  By using this module, you are changing the highest pair in the tables of both cpufreq and MPU frequencies, so it becomes 125, 250, 500 and, say, 800.  It's quite stable up to 1200; beyond that it quickly becomes unusable, specially over 1300, with lockups or spontaneous reboots.

For this to work, the module must know two memory addresses that are specific to each kernel. Since version 1.2 the kernel attempts to autodetect them if the parameter omap2_clk_init_cpufreq_table_addr (more on this below). Apart from this, the app is being developed in a Motorola Milestone UK with official Android 2.1 for Central Europe, build number SHOLS_U2_02.31.0. Fortunately Motorola appears to have used the same kernel in most of the 2.1 firmwares. Users with Russian and Thai firmwares reported failures (before autodetect) but after flashing the Central Europe kernel (in the Russian case) and Telus kernel (for Thai) it worked. You can see the different firmware/kernels available at [http://and-developers.com/motorola_milestone:sbf and-developers] (2.1 table), just make sure the WCDMA values of the new kernel match those of your country. To extract the kernel from a firmware use the [http://and-developers.com/motorola_milestone:sbf SBF Depacker] (thanks Skrilax). With Android 2.0.1 (again, before autodetect) new addresses must be supplied: freq_table_addr=0xc0509b24, mpu_opps_addr=0xc050a848 (French and UK Milestone -- Thanks laurent.commarieu and clausgedved). See the [Disassembly] page for detailed instructions on porting the module to different kernels or even other phones. Testers welcome!

== Usage ==

The module is created at /data/data/pt.com.darksun.milestoneoverclock/files/overclock.ko when it is first loaded through the app. Afterwards you can load and use it directly:

{{{
insmod overclock.ko
echo 62 > /proc/overclock/max_vsel
echo 800000 > /proc/overclock/max_rate
}}}
	
You should set max_vsel before max_rate if the new rate is going to be higher than the current one, because higher frequencies often require more voltage than supplied by default.  Likewise, lower the max_rate first before max_vsel if you want to reduce both frequency and voltage:

{{{
echo 550000 > /proc/overclock/max_rate
echo 56 > /proc/overclock/max_vsel
}}}

To set a specified frequency and voltage at load time:
{{{
insmod overclock.ko max_rate=800000 max_vsel=62
}}}

Remember that you are merely changing the maximum possible value that CPUfreq can choose to use.  The current speed may well be lower than the one specified if the phone is idle. I recommend the use of [http://www.pokedev.com/setcpu/ SetCPU] to effectively change the current frequency through CPUfreq policies.

===Autodetect===

You may also supply the addresses of the two needed in-memory kernel structures which may change with each firmware build and will probably have to be supplied either at load time with the freq_table_addr and mpu_opps_ptr_addr parameters or with their respective /proc entries. You can also ask the module to try to autodetect them if you give it the address of omap2_clk_init_cpufreq_table. The app does this automatically. You can easily find it manually with:

{{{
# grep omap2_clk_init_cpufreq_table /proc/kallsyms
c004e498 T omap2_clk_init_cpufreq_table
}}}

So now you can load the module with:

{{{
insmod overclock.ko omap2_clk_init_cpufreq_table_addr=0xc004e498
}}}

And in dmesg you should see something like this:

{{{
[ 9361.096099] overclock: found mpu_opps_addr at 0xc050c888
[ 9361.096405] overclock: found freq_table_addr at 0xc050bb68
}}}

If autodetect doesn't work for you, you can specify the values manually. For example to load a module for a French or UK Milestone with Android 2.0.1:

{{{
insmod overclock.ko freq_table_addr=0xc0509b24 mpu_opps_addr=0xc050a848
}}}

or you can configure the module while running, before setting/reading any other parameter:

{{{
echo 0xc0509b24 > /proc/overclock/freq_table_addr
echo 0xc050a848 > /proc/overclock/mpu_opps_addr
}}}

Finding out the values will require live disassembly of kernel code. See the [Disassembly] page for more information.

Also for the more hardcore among you, you can now change values directly in freq_table and mpu_opps with (that's "index freq" and "index rate vsel"):

{{{
echo "1 400000" > /proc/overclock/freq_table
echo "3 400000000 50" > /proc/overclock/mpu_opps
}}}

Check the results with cat /proc/overclock/freq_table and cat /proc/overclock/mpu_opps. This can be used for example to "underclock" your CPU and save battery, or to change any frequencies you wish, not just the highest one.

== Frequencies ==

The following table lists frequencies/voltages that appear to work well together, albeit with very conservative voltages. These are the values available in the app by default (thanks to kabaldan for corrections):

|| *Frequency (KHz)* || * vsel * || *Voltage (V)* ||
|| 550000 || 56 || 1.3 ||
|| 600000 || 62 || 1.375 ||
|| 800000 || 68 || 1.45 ||
|| 1000000 || 74 || 1.525 ||
|| 1200000 || 80 || 1.6 ||

The maximum vsel I could use was 127. The safe upper limit in the processor specs is 1.8V which translates to vsel 96 (according to [http://wiki.droidmod.org/doku.php?id=vsel_calc wikidroid]). Frequencies above 1250000 usually reboot spontaneously.

The community at [http://www.android-hilfe.de/root-hacking-modding-fuer-motorola-milestone/28049-overclocking-verwendete-spannungen.html android-hilfe] has made extensive tests to find exactly what range of voltage selections could be used in each frequency. There are variations because not all Milestones are made equal, some can handle higher voltages and frequencies than others. Here is a copy of the table they produced, available [http://www.android-hilfe.de/root-hacking-modding-fuer-motorola-milestone/28049-overclocking-verwendete-spannungen.html here] (thanks doc.payce!):

<table border="1" cellpadding="3">
<tbody align="center">
<tr><td></td><td colspan="3">*max_vsel*</td></tr>
<tr><td>*Frequency*</td><td>*Stable (>=)*</td><td>*Possibly unstable*</td><td>*Probably unstable (<=)*</td></tr>
<tr><td>550</td><td>56</td><td></td><td></td></tr>
<tr><td>800</td><td>58</td><td>56 .. 54</td><td>52</td></tr>
<tr><td>1000</td><td>60</td><td>58 .. 56</td><td>54</td></tr>
<tr><td>1100</td><td>64</td><td>62 .. 60</td><td>58</td></tr>
<tr><td>1200`*`</td><td>76</td><td>74 .. 70</td><td>68</td></tr>
<tr><td>1330`*`</td><td></td><td>84</td><td></td></tr>
</tbody>
</table>
`*`: Always unstable in some CPUs! Will damage CPU on prolonged use. According to OMAP3430 datasheet, max_vsel up to 66 should be acceptable. Above 80 will certainly severly damage the CPU on long-term scale. The most appropriate and stable settings seem to be either 800 MHz or 1000 MHz at max_vsel of 56 to 60.
